#!/usr/bin/env python

'''
  OnionPerf
  Authored by Rob Jansen
  See LICENSE for licensing information
'''

import sys, os, argparse, logging
from itertools import cycle
from socket import gethostname

import onionperf.util as util
from onionperf.monitor import get_supported_torctl_events

DESC_MAIN = """
OnionPerf is a utility to measure, analyze, and visualize the performance of
Tor and Onion Services.
\n\n
For more information, see https://github.com/robgjansen/onionperf.
"""
HELP_MAIN = """
OnionPerf must be run with a subcommand to specify a mode of operation. The
primary mode is measure, but tools to generate TGen models and to analyze
and visualize Tor and TGen output that is collected in the measure mode are
also available. Use 'onionperf <subcommand> --help' for more information.
"""

DESC_MONITOR = """
This utility connects to a running Tor (https://www.torproject.org) process on the Tor
control port, registers for several asynchronous events, and logs the events to disk
as they occur over time.
"""
HELP_MONITOR = """
Connects to a running Tor process with an open control port, and logs various asynchronous events
"""

DESC_MEASURE = """
OnionPerf uses multiple processes and threads to download random data through
Tor while tracking the performance of those downloads. The data is served and
fetched on localhost using two TGen (traffic generator) processes, but is
tranferred through Tor using a temporary Tor Hidden Service process and a
client process. Tor control information and TGen performance statistics are
logged to disk and can be later analyzed (using onionperf analyze) to
vizualize changes in Tor performance over time.
"""
HELP_MEASURE = """
Measure Tor and Onion Service Performance using TGen
"""

DESC_ANALYZE = """
Parse results from the TGen traffic generator and Tor.

This script enables processing of TGen and Tor log files and storing processed
data in json format for plotting. It was written so that the log files
need never be stored on disk decompressed, which is useful when log file
sizes reach tens of gigabytes.

The standard way to run this mode is to give the path to a directory tree
under which one or several TGen/Tor log files exist:
$ onionperf analyze shadow.data/hosts/

This path will be searched for log files whose names match those created
by OnionPerf and Shadow; additional patterns can be added with the '-e' option.

A single TGen/Tor log file can also be passed on STDIN with the special '-' path:
$ cat tgen.log | onionperf analyze -
$ xzcat tgen.log.xz | onionperf analyze -

The default mode is to filter and parse the log files using a single
process; configure multiple worker processes using the '-m' option.
"""
HELP_ANALYZE = """
Analyze Tor and TGen output
"""

DESC_VISUALIZE = """
Plot results produced by running the analyze subcommand of OnionPerf.
"""
HELP_VISUALIZE = """
Visualize OnionPerf analysis results
"""

DESC_MODEL = """
Write the TGen server and client models that OnionPerf uses in the measure mode to the specified file paths.
"""
HELP_MODEL = """
Generate TGen traffic models
"""

logging.basicConfig(format='%(asctime)s %(created)f [onionperf] [%(levelname)s] %(message)s', level=logging.INFO, datefmt='%Y-%m-%d %H:%M:%S')
logging.getLogger("stem").setLevel(logging.WARN)

def main():
    hostname = gethostname().split('.')[0]

    # construct the options
    main_parser = argparse.ArgumentParser(
        description=DESC_MAIN,
        formatter_class=argparse.RawDescriptionHelpFormatter)  # RawTextHelpFormatter, RawDescriptionHelpFormatter

    sub_parser = main_parser.add_subparsers(help=HELP_MAIN)

    # monitor
    monitor_parser = sub_parser.add_parser('monitor', description=DESC_MONITOR, help=HELP_MONITOR)
    monitor_parser.set_defaults(func=monitor, formatter_class=argparse.RawDescriptionHelpFormatter)

    monitor_parser.add_argument('-p', '--port',
        help="""the Tor control port number N""",
        metavar="N", type=type_nonnegative_integer,
        action="store", dest="ctlport",
        default=9050)

    monitor_parser.add_argument('-e', '--event',
        help="""the Tor control EVENT(s) that should be monitored and logged""",
        metavar="EVENT", nargs='+',
        action="store", dest="events",
        default=get_supported_torctl_events(),
        choices=get_supported_torctl_events())

    monitor_parser.add_argument('-l', '--log',
        help="""a file PATH to log Tor controller output, may be '-' for STDOUT""",
        metavar="PATH", type=type_str_path_out,
        action="store", dest="logpath",
        default="-")

    # measure
    measure_parser = sub_parser.add_parser('measure', description=DESC_MEASURE, help=HELP_MEASURE)
    measure_parser.set_defaults(func=measure, formatter_class=argparse.RawDescriptionHelpFormatter)

    measure_parser.add_argument('--tor',
        help="""a file PATH to a Tor binary""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="torpath",
        default=util.which("tor"))

    measure_parser.add_argument('--tgen',
        help="""a file PATH to a TGen binary""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="tgenpath",
        default=util.which("tgen"))

    measure_parser.add_argument('--twistd',
        help="""a file PATH to a twistd binary""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="twistdpath",
        default=util.which("twistd"))

    measure_parser.add_argument('--tgen-port',
        help="""the TGen server port number N, must be Internet-accessible for non-onion downloads to work""",
        metavar="N", type=type_nonnegative_integer,
        action="store", dest="tgenport",
        default=80)

    measure_parser.add_argument('--twistd-port',
        help="""the Twistd web server port number N, where OnionPerf results can be fetched""",
        metavar="N", type=type_nonnegative_integer,
        action="store", dest="twistdport",
        default=50080)

    measure_parser.add_argument('-p', '--prefix',
        help="""a directory PATH prefix where OnionPerf will run""",
        metavar="PATH", type=type_str_path_out,
        action="store", dest="prefix",
        default=os.getcwd() + "/onionperf-data")

    measure_parser.add_argument('-i', '--no-inet',
        help="""disable measuring download times over Tor back to {0}""".format(hostname),
        action="store_false", dest="do_inet",
        default=True)

    measure_parser.add_argument('-o', '--no-onion',
        help="""disable measuring download times over Tor to an ephemeral onion service""",
        action="store_false", dest="do_onion",
        default=True)

    measure_parser.add_argument('-n', '--nickname',
        help="""the 'SOURCE' STRING to use in .tpf torperf stats files produced by OnionPerf""",
        metavar="STRING", type=str,
        action="store", dest="nickname",
        default=hostname)

    measure_parser.add_argument('-m', '--traffic-model',
        help="""a file PATH to a TGen graphml XML traffic model, to use *instead* of the
built-in Torperf (50KiB, 1MiB, 5MiB) traffic model""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="model",
        default=None)

    # analyze
    analyze_parser = sub_parser.add_parser('analyze', description=DESC_ANALYZE, help=HELP_ANALYZE)
    analyze_parser.set_defaults(func=analyze, formatter_class=argparse.RawDescriptionHelpFormatter)

    analyze_parser.add_argument('--tgen',
        help="""a file PATH to a TGen logfile""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="tgen_logpath",
        default=None)

    analyze_parser.add_argument('--torctl',
        help="""a file PATH to a TorCtl logfile (in the format output by the monitor subcommmand)""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="torctl_logpath",
        default=None)

    analyze_parser.add_argument('-p', '--prefix',
        help="""A directory PATH prefix where the processed data
files generated by this script will be written""",
        metavar="PATH", type=type_str_path_out,
        action="store", dest="prefix",
        default=os.getcwd())

    analyze_parser.add_argument('-n', '--nickname',
        help="""a nickname STRING that identifies the machine where the input logfiles were produced""",
        metavar="STRING", type=str,
        action="store", dest="nickname",
        default=None)

    analyze_parser.add_argument('-s', '--do-simple-parse',
        help="""parse and export only summary statistics rather than full transfer/circuit/stream data""",
        action="store_true", dest="do_simple",
        default=False)

    analyze_parser.add_argument('-t', '--torperf',
        help="""export transfer data in Torperf format in addition to OnionPerf format""",
        action="store_true", dest="save_torperf",
        default=False)

#     analyze_parser = sub_parser.add_parser('analyze', description=DESC_ANALYZE, help=HELP_ANALYZE)
#     analyze_parser.set_defaults(func=analyze, formatter_class=argparse.RawDescriptionHelpFormatter)
#
#     analyze_parser.add_argument(
#         help="""The PATH to search for tgen and tor log files, which may be '-'
# for STDIN; each log file may end in '.xz' to enable
# inline xz decompression""",
#         metavar="PATH", type=type_str_path_in,
#         action="store", dest="searchpath")
#
#     analyze_parser.add_argument('-t', '--type',
#         help="""The TYPE of Analysis to perform, which may be 'tgen', 'tor', or 'all'""",
#         metavar="TYPE", type=type_supported_analysis,
#         action="store", dest="atype",
#         default="all")
#
#     analyze_parser.add_argument('-e', '--expression',
#         help="""Append a regex PATTERN to the list of strings used with
# re.search to find log file names in the search path""",
#         metavar="PATTERN", type=str,
#         action="append", dest="patterns",
#         default=[])
#
#     analyze_parser.add_argument('-m', '--multiproc',
#         help="""Enable multiprocessing with N worker process, which may be '0'
# to use the number of processor cores""",
#         metavar="N", type=type_nonnegative_integer,
#         action="store", dest="nprocesses",
#         default=1)
#
#     analyze_parser.add_argument('-p', '--prefix',
#         help="""A directory PATH prefix where the processed data
# files generated by this script will be written""",
#         metavar="PATH", type=type_str_path_out,
#         action="store", dest="prefix",
#         default=os.getcwd())
#
#     analyze_parser.add_argument('-n', '--nickname',
#         help="""the 'SOURCE' STRING to use in .tpf torperf stats files produced by OnionPerf""",
#         metavar="STRING", type=str,
#         action="store", dest="nickname",
#         default=None)

    # visualize
    visualize_parser = sub_parser.add_parser('visualize', description=DESC_VISUALIZE, help=HELP_VISUALIZE)
    visualize_parser.set_defaults(func=visualize, formatter_class=argparse.RawDescriptionHelpFormatter)

    visualize_parser.add_argument('-d', '--data',
        help="""Append a PATH to a onionperf.analysis.json analysis results file, and a LABEL that we
        should use for the graph legend for this dataset""",
        metavar=("PATH", "LABEL"),
        nargs=2,
        required="True",
        action=PathStringArgsAction, dest="datasets")

    visualize_parser.add_argument('-p', '--prefix',
        help="a STRING filename prefix for graphs we generate",
        metavar="STRING", type=str,
        action="store", dest="prefix",
        default=None)

    visualize_parser.add_argument('-f', '--format',
        help="""A comma-separated LIST of color/line format strings to cycle to
                matplotlib's plot command (see matplotlib.pyplot.plot)""",
        metavar="LIST", type=str,
        action="store", dest="lineformats",
        default=util.LINEFORMATS)

    # model
    model_parser = sub_parser.add_parser('model', description=DESC_MODEL, help=HELP_MODEL)
    model_parser.set_defaults(func=model, formatter_class=argparse.RawDescriptionHelpFormatter)

    model_parser.add_argument('-d', '--domain-name',
        help="""a STRING domain name or IP address (e.g. 'torproject.org')""",
        metavar="STRING", type=str,
        action="store", dest="domain_name",
        required=True)

    model_parser.add_argument('-o', '--onion-name',
        help="""a STRING onion name (e.g. 'xyz.onion')""",
        metavar="STRING", type=str,
        action="store", dest="onion_name",
        required=True)

    model_parser.add_argument('-s', '--tgen-server-filepath',
        help="""a file PATH to save the TGen server model used by OnionPerf""",
        metavar="PATH", type=type_str_path_out,
        action="store", dest="server_fpath",
        default="tgen-server.graphml.xml")

    model_parser.add_argument('-t', '--tgen-torperf-client-filepath',
        help="""a file PATH to save the TGen Torperf client model used by OnionPerf""",
        metavar="PATH", type=type_str_path_out,
        action="store", dest="client_fpath",
        default="tgen-torperf-client.graphml.xml")

    # get args and call the command handler for the chosen mode
    args = main_parser.parse_args()
    args.func(args)

def monitor(args):
    from onionperf.monitor import TorMonitor

    eventstr = ','.join(args.events)

    writer = util.FileWritable(args.logpath)
    mon = TorMonitor(args.ctlport, writer, events=args.events)
    try:
        fname = 'STDOUT' if args.logpath == '-' else args.logpath
        startup_msg = "tor-ctl-logger started logging Tor events {0} from port {1} to {2}".format(eventstr, args.ctlport, fname)
        logging.info(startup_msg)
        mon.run()
        logging.info("tor-ctl-logger is done logging Tor events {0} from port {1}".format(eventstr, args.ctlport))
    except KeyboardInterrupt:
        pass  # the user hit ctrl+c
    writer.close()

def measure(args):
    from onionperf.measurement import Measurement

    # check paths
    args.torpath = util.find_path(args.torpath, "tor")
    if args.torpath is not None: args.tgenpath = util.find_path(args.tgenpath, "tgen")
    if args.torpath is not None and args.tgenpath is not None: args.twistdpath = util.find_path(args.twistdpath, "twistd")

    # validate paths and run
    if args.torpath is not None and args.tgenpath is not None and args.twistdpath is not None:
        os.chdir(args.prefix)
        if args.model:
            # load custom model instead of Torperf model
            pass
        else:
            # build a Torperf model
            # model.TorperfModel(tgen_port="{0}".format(tgen_port), tgen_servers=server_urls, socksproxy="127.0.0.1:{0}".format(socks_port))
            pass
        client_tgen_port = util.get_random_free_port()
        client_tor_ctl_port = util.get_random_free_port()
        client_tor_socks_port = util.get_random_free_port(),
        server_tgen_port = args.tgenport
        server_tor_ctl_port = util.get_random_free_port()
        server_tor_socks_port = util.get_random_free_port()
        twistd_port = args.twistdport

        meas = Measurement(args.torpath, args.tgenpath, args.twistdpath, args.prefix, args.nickname)
        meas.run(do_onion=args.do_onion, do_inet=args.do_inet,
             client_tgen_port=client_tgen_port, client_tor_ctl_port=client_tor_ctl_port, client_tor_socks_port=client_tor_socks_port,
             server_tgen_port=server_tgen_port, server_tor_ctl_port=server_tor_ctl_port, server_tor_socks_port=server_tor_socks_port, twistd_port=twistd_port)
    else:
        logging.info("Please fix path errors to continue")

def analyze(args):
    from onionperf.analysis import Analysis

    if args.tgen_logpath is None and args.torctl_logpath is None:
        logging.warning("No logfile paths were given, nothing will be analyzed")
        return

    analysis = Analysis(nickname=args.nickname)

    if args.tgen_logpath is not None:
        analysis.add_tgen_file(args.tgen_logpath)
    if args.torctl_logpath is not None:
        analysis.add_torctl_file(args.torctl_logpath)

    analysis.analyze(args.do_simple)
    analysis.save(output_prefix=args.prefix)
    if args.save_torperf:
        analysis.export_torperf_version_1_0(output_prefix=args.prefix, do_compress=True)

def visualize(args):
    from onionperf.visualization import TGenVisualization, TorVisualization
    from onionperf.analysis import Analysis

    lflist = args.lineformats.strip().split(",")
    lfcycle = cycle(lflist)

    tgen_viz = TGenVisualization()
    tor_viz = TorVisualization()

    for (path, label) in args.datasets:
        nextformat = lfcycle.next()

        anal = Analysis.load(filename=path)
        if anal is not None:
            tgen_viz.add_dataset(anal, label, nextformat)
            tor_viz.add_dataset(anal, label, nextformat)

    tgen_viz.plot_all(args.prefix)
    tor_viz.plot_all(args.prefix)

def model(args):
    from onionperf.model import ListenModel, TorperfModel

    # clean the args and create non-existent directories
    args.client_fpath = util.make_path(args.client_fpath)
    args.server_fpath = util.make_path(args.server_fpath)

    # generate the models
    # the server listens on 8888, the client uses Tor to come back directly, and using a hidden serv
    server = ListenModel(tgen_port="8888")
    public_server_str = "{0}:8888".format(args.domain_name)
    onion_server_str = "{0}:8890".format(args.onion_name)
    client = TorperfModel(tgen_port="8889", socksproxy="localhost:9001", tgen_servers=[public_server_str, onion_server_str])

    # save to specified paths
    server.dump_to_file(args.server_fpath)
    client.dump_to_file(args.client_fpath)

def type_nonnegative_integer(value):
    i = int(value)
    if i < 0: raise argparse.ArgumentTypeError("%s is an invalid non-negative int value" % value)
    return i

def type_supported_analysis(value):
    t = value.lower()
    if t != "all" and t != "tgen" and t != "tor":
        raise argparse.ArgumentTypeError("%s is an invalid Analysis type" % value)
    return t

def type_str_path_out(value):
    s = str(value)
    if s == "-":
        return s
    p = os.path.abspath(os.path.expanduser(s + "/"))
    util.make_path(p)
    return p

def type_str_path_in(value):
    s = str(value)
    if s == "-":
        return s
    p = os.path.abspath(os.path.expanduser(s))
    if not os.path.exists(p):
        raise argparse.ArgumentTypeError("path %s does not exist" % s)
    return p

# a custom action for passing in experimental data directories when plotting
class PathStringArgsAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        # extract the path to our data, and the label for the legend
        p = os.path.abspath(os.path.expanduser(values[0]))
        s = values[1]
        # check the path exists
        if not os.path.exists(p): raise argparse.ArgumentError(self, "The supplied path does not exist: '{0}'".format(p))
        # remove the default
        if "_didremovedefault" not in namespace:
            setattr(namespace, self.dest, [])
            setattr(namespace, "_didremovedefault", True)
        # append out new experiment path
        dest = getattr(namespace, self.dest)
        dest.append((p, s))

if __name__ == '__main__': sys.exit(main())
